/**
 * Test Completo: Caracter√≠sticas SQL Avanzadas ‚Üí MongoDB
 * Validaci√≥n de GROUP BY, HAVING, ORDER BY, LIMIT, OFFSET en MongoDB
 */

import { MongoDB } from '../MongoDB.js';

async function testSQLAvanzado() {
  console.log('üöÄ Test Completo: Caracter√≠sticas SQL Avanzadas ‚Üí MongoDB\n');

  try {
    const mongodb = new MongoDB();

    // ===========================================
    // 1. TEST GROUP BY B√ÅSICO
    // ===========================================
    console.log('üìä 1. Test GROUP BY b√°sico...');

    const groupByCmd = mongodb.select(['category', 'total']);
    mongodb.from('products', null, groupByCmd);
    mongodb.groupBy('category', { total: { $count: {} } }, groupByCmd);

    console.log('‚úÖ GROUP BY construido:');
    console.log('   SQL: SELECT category, COUNT(*) as total FROM products GROUP BY category');
    console.log('   MongoDB Aggregation:');
    console.log('   ', JSON.stringify(groupByCmd._commands[0].buildFinalCommand(groupByCmd), null, 2));

    // ===========================================
    // 2. TEST GROUP BY M√öLTIPLES CAMPOS
    // ===========================================
    console.log('\nüìä 2. Test GROUP BY m√∫ltiples campos...');

    const multiGroupCmd = mongodb.select(['user_id', 'status', 'count', 'total']);
    mongodb.from('orders', null, multiGroupCmd);
    mongodb.groupBy(['user_id', 'status'], {
      count: { $count: {} },
      total: { $sum: '$amount' }
    }, multiGroupCmd);

    console.log('‚úÖ GROUP BY m√∫ltiple construido:');
    console.log('   SQL: SELECT user_id, status, COUNT(*) as count, SUM(amount) as total');
    console.log('        FROM orders GROUP BY user_id, status');
    console.log('   MongoDB Aggregation:');
    console.log('   ', JSON.stringify(multiGroupCmd._commands[0].buildFinalCommand(multiGroupCmd), null, 2));

    // ===========================================
    // 3. TEST GROUP BY + HAVING
    // ===========================================
    console.log('\nüìä 3. Test GROUP BY + HAVING...');

    const havingCmd = mongodb.select(['category', 'total']);
    mongodb.from('products', null, havingCmd);
    mongodb.groupBy('category', { total: { $count: {} } }, havingCmd);
    mongodb.having({ total: { $gt: 5 } }, havingCmd);

    console.log('‚úÖ GROUP BY + HAVING construido:');
    console.log('   SQL: SELECT category, COUNT(*) as total FROM products');
    console.log('        GROUP BY category HAVING COUNT(*) > 5');
    console.log('   MongoDB Aggregation:');
    console.log('   ', JSON.stringify(havingCmd._commands[0].buildFinalCommand(havingCmd), null, 2));

    // ===========================================
    // 4. TEST ORDER BY SIMPLE
    // ===========================================
    console.log('\nüî§ 4. Test ORDER BY simple...');

    const orderCmd = mongodb.select(['name', 'age']);
    mongodb.from('users', null, orderCmd);
    mongodb.orderBy('name', 'asc', orderCmd);

    console.log('‚úÖ ORDER BY simple construido:');
    console.log('   SQL: SELECT name, age FROM users ORDER BY name ASC');
    console.log('   MongoDB Aggregation:');
    console.log('   ', JSON.stringify(orderCmd._commands[0].buildFinalCommand(orderCmd), null, 2));

    // ===========================================
    // 5. TEST ORDER BY M√öLTIPLE
    // ===========================================
    console.log('\nüî§ 5. Test ORDER BY m√∫ltiple...');

    const multiOrderCmd = mongodb.select(['name', 'age']);
    mongodb.from('users', null, multiOrderCmd);
    mongodb.orderBy([
      { field: 'age', direction: 'desc' },
      { field: 'name', direction: 'asc' }
    ], null, multiOrderCmd);

    console.log('‚úÖ ORDER BY m√∫ltiple construido:');
    console.log('   SQL: SELECT name, age FROM users ORDER BY age DESC, name ASC');
    console.log('   MongoDB Aggregation:');
    console.log('   ', JSON.stringify(multiOrderCmd._commands[0].buildFinalCommand(multiOrderCmd), null, 2));

    // ===========================================
    // 6. TEST LIMIT
    // ===========================================
    console.log('\nüìè 6. Test LIMIT...');

    const limitCmd = mongodb.select(['name']);
    mongodb.from('users', null, limitCmd);
    mongodb.limit(10, limitCmd);

    console.log('‚úÖ LIMIT construido:');
    console.log('   SQL: SELECT name FROM users LIMIT 10');
    console.log('   MongoDB Aggregation:');
    console.log('   ', JSON.stringify(limitCmd._commands[0].buildFinalCommand(limitCmd), null, 2));

    // ===========================================
    // 7. TEST OFFSET + LIMIT (PAGINACI√ìN)
    // ===========================================
    console.log('\nüìÑ 7. Test OFFSET + LIMIT (paginaci√≥n)...');

    const paginationCmd = mongodb.select(['name', 'email']);
    mongodb.from('users', null, paginationCmd);
    mongodb.offset(20, paginationCmd);
    mongodb.limit(10, paginationCmd);

    console.log('‚úÖ Paginaci√≥n construida:');
    console.log('   SQL: SELECT name, email FROM users OFFSET 20 LIMIT 10');
    console.log('   MongoDB Aggregation:');
    console.log('   ', JSON.stringify(paginationCmd._commands[0].buildFinalCommand(paginationCmd), null, 2));

    // ===========================================
    // 8. TEST CONSULTA COMPLEJA COMBINADA
    // ===========================================
    console.log('\nüéØ 8. Test consulta compleja combinada...');

    const complexCmd = mongodb.select(['u.name', 'category', 'total_amount', 'order_count']);
    mongodb.from('users', 'u', complexCmd);
    mongodb.join('orders', 'u.id = o.user_id', 'inner', 'o', complexCmd);
    mongodb.where({ 'o.status': 'completed' }, complexCmd);
    mongodb.groupBy(['u.name', 'o.category'], {
      total_amount: { $sum: '$o.amount' },
      order_count: { $count: {} }
    }, complexCmd);
    mongodb.having({ total_amount: { $gt: 1000 } }, complexCmd);
    mongodb.orderBy('total_amount', 'desc', complexCmd);
    mongodb.limit(5, complexCmd);

    console.log('‚úÖ Consulta compleja construida:');
    console.log('   SQL: SELECT u.name, o.category, SUM(o.amount) as total_amount, COUNT(*) as order_count');
    console.log('        FROM users u');
    console.log('        INNER JOIN orders o ON u.id = o.user_id');
    console.log('        WHERE o.status = "completed"');
    console.log('        GROUP BY u.name, o.category');
    console.log('        HAVING SUM(o.amount) > 1000');
    console.log('        ORDER BY total_amount DESC');
    console.log('        LIMIT 5');
    console.log('   MongoDB Aggregation:');
    console.log('   ', JSON.stringify(complexCmd._commands[0].buildFinalCommand(complexCmd), null, 2));

    // ===========================================
    // 9. TEST DE VALIDACIONES
    // ===========================================
    console.log('\nüîç 9. Test de validaciones...');

    try {
      // Test HAVING sin GROUP BY
      const invalidCmd = mongodb.select(['name']);
      mongodb.from('users', null, invalidCmd);
      mongodb.having({ count: { $gt: 5 } }, invalidCmd);
      console.log('‚ùå HAVING sin GROUP BY deber√≠a fallar');
    } catch (error) {
      console.log('‚úÖ HAVING sin GROUP BY correctamente rechazado:', error.message);
    }

    try {
      // Test LIMIT con valor inv√°lido
      const invalidLimitCmd = mongodb.select(['name']);
      mongodb.from('users', null, invalidLimitCmd);
      mongodb.limit(-5, invalidLimitCmd);
      console.log('‚ùå LIMIT negativo deber√≠a fallar');
    } catch (error) {
      console.log('‚úÖ LIMIT negativo correctamente rechazado:', error.message);
    }

    try {
      // Test OFFSET con valor inv√°lido
      const invalidOffsetCmd = mongodb.select(['name']);
      mongodb.from('users', null, invalidOffsetCmd);
      mongodb.offset('invalid', invalidOffsetCmd);
      console.log('‚ùå OFFSET inv√°lido deber√≠a fallar');
    } catch (error) {
      console.log('‚úÖ OFFSET inv√°lido correctamente rechazado:', error.message);
    }

    // ===========================================
    // 10. RESUMEN DE FUNCIONALIDADES
    // ===========================================
    console.log('\nüìã 10. Resumen de funcionalidades implementadas...');

    console.log('\n‚úÖ GROUP BY IMPLEMENTADO:');
    console.log('   ‚Ä¢ Campos simples: groupBy("category")');
    console.log('   ‚Ä¢ M√∫ltiples campos: groupBy(["user_id", "status"])');
    console.log('   ‚Ä¢ Funciones agregaci√≥n: { $count: {}, $sum: "$field", $avg: "$field" }');
    console.log('   ‚Ä¢ Pipeline: $group con _id y agregaciones');

    console.log('\n‚úÖ HAVING IMPLEMENTADO:');
    console.log('   ‚Ä¢ Filtrado post-GROUP BY: having({ total: { $gt: 5 } })');
    console.log('   ‚Ä¢ Validaci√≥n: requiere GROUP BY previo');
    console.log('   ‚Ä¢ Pipeline: $match despu√©s de $group');

    console.log('\n‚úÖ ORDER BY IMPLEMENTADO:');
    console.log('   ‚Ä¢ Campo simple: orderBy("name", "asc")');
    console.log('   ‚Ä¢ M√∫ltiples campos: orderBy([{field: "age", direction: "desc"}])');
    console.log('   ‚Ä¢ Formato MongoDB: orderBy({ age: -1, name: 1 })');
    console.log('   ‚Ä¢ Pipeline: $sort con especificaci√≥n completa');

    console.log('\n‚úÖ LIMIT/OFFSET IMPLEMENTADO:');
    console.log('   ‚Ä¢ L√≠mite: limit(10)');
    console.log('   ‚Ä¢ Offset: offset(20) o skip(20)');
    console.log('   ‚Ä¢ Paginaci√≥n: offset(20) + limit(10)');
    console.log('   ‚Ä¢ Pipeline: $skip + $limit en orden correcto');
    console.log('   ‚Ä¢ Validaciones: n√∫meros positivos requeridos');

    console.log('\n‚úÖ INTEGRACI√ìN COMPLETA:');
    console.log('   ‚Ä¢ Pipeline autom√°tico: detecta cu√°ndo usar aggregation vs find');
    console.log('   ‚Ä¢ Orden correcto: WHERE ‚Üí JOIN ‚Üí GROUP BY ‚Üí HAVING ‚Üí ORDER BY ‚Üí SKIP ‚Üí LIMIT');
    console.log('   ‚Ä¢ Compatibilidad: funciona con JOINs existentes');
    console.log('   ‚Ä¢ Validaciones: errores claros para casos inv√°lidos');

    console.log('\nüéØ CASOS DE USO CUBIERTOS:');
    console.log('   ‚Ä¢ Reportes con agrupaci√≥n y totales');
    console.log('   ‚Ä¢ Consultas con paginaci√≥n');
    console.log('   ‚Ä¢ An√°lisis estad√≠sticos con filtros');
    console.log('   ‚Ä¢ Dashboards con datos agregados');
    console.log('   ‚Ä¢ APIs REST con ordenamiento y l√≠mites');

  } catch (error) {
    console.error('‚ùå Error en test SQL avanzado:', error);
    console.error('Stack:', error.stack);
  }
}

// Funci√≥n adicional para test de performance conceptual
async function testPerformancePatterns() {
  console.log('\nüèÉ Test de patrones de performance...');

  const mongodb = new MongoDB();

  // Patr√≥n 1: Optimizaci√≥n de WHERE antes de JOIN
  console.log('\nüìà Patr√≥n 1: WHERE antes de JOIN (optimizado)');
  const optimizedCmd = mongodb.select(['u.name', 'o.total']);
  mongodb.from('users', 'u', optimizedCmd);
  mongodb.where({ 'u.active': true }, optimizedCmd); // WHERE antes de JOIN
  mongodb.join('orders', 'u.id = o.user_id', 'inner', 'o', optimizedCmd);

  const pipeline1 = optimizedCmd._commands[0].buildFinalCommand(optimizedCmd);
  console.log('‚úÖ Pipeline optimizado (WHERE ‚Üí JOIN):');
  console.log('   ', JSON.stringify(pipeline1.pipeline, null, 2));

  // Patr√≥n 2: GROUP BY con √≠ndices impl√≠citos
  console.log('\nüìà Patr√≥n 2: GROUP BY con agregaciones eficientes');
  const efficientCmd = mongodb.select(['category', 'avg_price', 'total_products']);
  mongodb.from('products', null, efficientCmd);
  mongodb.groupBy('category', {
    avg_price: { $avg: '$price' },
    total_products: { $count: {} }
  }, efficientCmd);
  mongodb.orderBy('avg_price', 'desc', efficientCmd);

  const pipeline2 = efficientCmd._commands[0].buildFinalCommand(efficientCmd);
  console.log('‚úÖ Pipeline eficiente (GROUP BY ‚Üí ORDER BY):');
  console.log('   ', JSON.stringify(pipeline2.pipeline, null, 2));
}

// Ejecutar tests
console.log('üé¨ Iniciando Tests de Caracter√≠sticas SQL Avanzadas...\n');
testSQLAvanzado().then(() => {
  return testPerformancePatterns();
}).catch(console.error);
